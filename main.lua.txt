if game.PlaceId == 142823291 then
-- WindUI
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- Locals  
local Players = game:GetService("Players")  
--Beach Ball Farm Variables  
local beachBallFarmEnabled = false  
local beachBallFarmDelay = 2.5  
local map = nil  
local RunService = game:GetService("RunService")  
local ReplicatedStorage = game:GetService("ReplicatedStorage")  
local Workspace = game:GetService("Workspace")  
-- Beach Ball Map Detection

Workspace.DescendantAdded:Connect(function(m)
if m:IsA("Model") and m.Name == "CoinContainer" then
map = m
end
end)

local CurrentCamera = Workspace.CurrentCamera  
local LocalPlayer = Players.LocalPlayer  
-- Beach Ball Character Setup  
local humPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")  
LocalPlayer.CharacterAdded:Connect(function(char)  
humPart = char:WaitForChild("HumanoidRootPart")

end)

local CoreGui = game:GetService("CoreGui")  

function gradient(text, startColor, endColor)  
    local result = ""  
    local length = #text  

    for i = 1, length do  
        local t = (i - 1) / math.max(length - 1, 1)  
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)  
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)  
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)  

        local char = text:sub(i, i)  
        result = result .. '<font color="rgb(' .. r .. ", " .. g .. ", " .. b .. ')">' .. char .. "</font>"  
    end  

    return result  
end  

local Confirmed = false  

WindUI:Popup(  
    {  
        Title = gradient("MadoHub", Color3.fromHex("#eb1010"), Color3.fromHex("#1023eb")),  
        Icon = "info",  
        Content = gradient("This script is made by", Color3.fromHex("#10eb3c"), Color3.fromHex("#67c97a")) ..  
            gradient(" Mado", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),  
        Buttons = {  
            {  
                Title = gradient("Cancel", Color3.fromHex("#e80909"), Color3.fromHex("#630404")),  
                Callback = function()  
                end,  
                Variant = "Tertiary" -- Primary, Secondary, Tertiary  
            },  
            {  
                Title = gradient("Load", Color3.fromHex("#90f09e"), Color3.fromHex("#13ed34")),  
                Callback = function()  
                    Confirmed = true  
                end,  
                Variant = "Secondary" -- Primary, Secondary, Tertiary  
            }  
        }  
    }  
)  

repeat  
    task.wait()  
until Confirmed  

WindUI:Notify(  
    {  
        Title = gradient("MadoHub", Color3.fromHex("#eb1010"), Color3.fromHex("#1023eb")),  
        Content = "",  
        Icon = "check-circle",  
        Duration = 3  
    }  
)  

-- Window  
local Window =  
    WindUI:CreateWindow(  
    {  
        Title = gradient("MadoHub", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),  
        Icon = "infinity",  
        Author = gradient("Murder Mystery 2", Color3.fromHex("#1bf2b2"), Color3.fromHex("#1bcbf2")),  
        Folder = "WindUI",  
        Size = UDim2.fromOffset(300, 270),  
        Transparent = true,  
        Theme = "Dark",  
        SideBarWidth = 200,  
        UserEnabled = true,  
        HasOutline = true  
    }  
)  

-- Open Button  
Window:EditOpenButton(  
    {  
        Title = "Open UI",  
        Icon = "monitor",  
        CornerRadius = UDim.new(2, 6),  
        StrokeThickness = 2,  
        Color = ColorSequence.new(Color3.fromHex("1E213D"), Color3.fromHex("1F75FE")),  
        Draggable = true  
    }  
)  

-- Tabs  
local Tabs = {  
    MainTab = Window:Tab(  
        {Title = gradient("MAIN", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "terminal"}  
    ),  
    CharacterTab = Window:Tab(  
        {Title = gradient("CHARACTER", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "file-cog"}  
    ),  
    TeleportTab = Window:Tab(  
        {Title = gradient("TELEPORT", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "user"}  
    ),  
    EspTab = Window:Tab(  
        {Title = gradient("ESP", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "eye"}  
    ),  
    AimbotTab = Window:Tab(  
        {Title = gradient("AIMBOT", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "arrow-right"}  
    ),  
    CombatTab = Window:Tab(  
        {Title = gradient("COMBAT", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "sword"}  
    ),  
    AutoFarm = Window:Tab(  
        {Title = gradient("AUTOFARM", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "coin"}  
    ),  
    ServerTab = Window:Tab(  
        {Title = gradient("SERVER", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "atom"}  
    ),  
    beed = Window:Divider(),  
    SettingsTab = Window:Tab(  
        {Title = gradient("SETTINGS", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "code"}  
    ),  
    ChangelogsTab = Window:Tab(  
        {Title = gradient("CHANGELOGS", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "info"}  
    ),  
    SocialsTab = Window:Tab(  
        {Title = gradient("SOCIALS", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")), Icon = "star"}  
    ),  
    b = Window:Divider(),  
    WindowTab = Window:Tab(  
        {  
            Title = gradient("CONFIGURATION", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")),  
            Icon = "settings",  
            Desc = "Manage window settings and file configurations."  
        }  
    ),  
    CreateThemeTab = Window:Tab(  
        {  
            Title = gradient("THEMES", Color3.fromHex("#ffffff"), Color3.fromHex("#636363")),  
            Icon = "palette",  
            Desc = "Design and apply custom themes."  
        }  
    )  
}  


-- AutoFarm Tab - Beach Ball Farm Section
Tabs.AutoFarm:Section({Title = gradient("Beach Ball Farm", Color3.fromHex("#00e1ff"), Color3.fromHex("#0066ff"))})

Tabs.AutoFarm:Paragraph({
    Title = "SAFE FARMING",
    Desc = "Using ultra-slow movement for maximum safety",
    Image = "https://play-lh.googleusercontent.com/7cIIPlWm4m7AGqVpEsIfyL-HW4cQla4ucXnfalMft1TMIYQIlf2vqgmthlZgbNAQoaQ",
    ImageSize = 42
})

-- Settings
local beachBallsCollected = 0
local lastNotificationTime = 0

-- Toggle for Beach Ball Farm
Tabs.AutoFarm:Toggle({
    Title = "Enable Beach Ball Farm",
    Default = false,
    Callback = function(state)
        getgenv().farm = state
        if state then
            beachBallsCollected = 0  -- Reset counter
            WindUI:Notify({
                Title = "FARM STARTED",
                Content = "Slowly collecting Beach Balls...",
                Icon = "loader",
                Duration = 2
            })
            
            coroutine.wrap(function()
                local TweenService = game:GetService("TweenService")
                while getgenv().farm do
                    -- Find coins
                    if not map or not map.Parent then
                        map = workspace:FindFirstChild("CoinContainer")
                    end
                    
                    if map then
                        for _, coin in ipairs(map:GetChildren()) do
                            if not getgenv().farm then break end
                            if coin.Name == "Coin_Server" and coin:GetAttribute("CoinID") == "BeachBall" then
                                local humanoidRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                                if not humanoidRoot then break end
                                
                                -- Smoother movement
                                for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
                                    if part:IsA("BasePart") then
                                        part.CanCollide = false
                                    end
                                end
                                
                                -- Very slow tween (3 seconds duration)
                                local tween = TweenService:Create(
                                    humanoidRoot,
                                    TweenInfo.new(3, Enum.EasingStyle.Linear),
                                    {CFrame = coin.CFrame}
                                )
                                tween:Play()
                                
                                -- Wait for collection
                                local startTime = tick()
                                while tick() - startTime < 3 and getgenv().farm do
                                    task.wait()
                                end
                                
                                -- Update counter
                                beachBallsCollected += 1
                                if tick() - lastNotificationTime > 3 then  -- Throttle notifications
                                    WindUI:Notify({
                                        Title = "COLLECTED",
                                        Content = string.format("%d Beach Balls (This Server)", beachBallsCollected),
                                        Icon = "dollar-sign",
                                        Duration = 1.5
                                    })
                                    lastNotificationTime = tick()
                                end
                            end
                        end
                    end
                    task.wait(0.1)
                end
            end)()
        else
            WindUI:Notify({
                Title = "FARM STOPPED",
                Content = string.format("Total Collected: %d", beachBallsCollected),
                Icon = "check-circle",
                Duration = 3
            })
        end
    end
})

-- Emergency Stop
Tabs.AutoFarm:Button({
    Title = "üõë STOP FARMING",
    Callback = function()
        getgenv().farm = false
        WindUI:Notify({
            Title = "EMERGENCY STOP",
            Content = string.format("Collected %d before stopping", beachBallsCollected),
            Icon = "alert-triangle",
            Duration = 3,
            Color = Color3.fromRGB(255, 50, 50)
        })
    end
})


-- Character  
local Players = game:GetService("Players")  
local RunService = game:GetService("RunService")  
local LocalPlayer = Players.LocalPlayer  

local CharacterSettings = {  
    WalkSpeed = {Value = 16, Default = 16, Locked = false},  
    JumpPower = {Value = 50, Default = 50, Locked = false}  
}  

local function updateCharacter()  
    local character = LocalPlayer.Character  
    local humanoid = character:FindFirstChildOfClass("Humanoid")  
    if humanoid then  
        if not CharacterSettings.WalkSpeed.Locked then  
            humanoid.WalkSpeed = CharacterSettings.WalkSpeed.Value  
        end  
        if not CharacterSettings.JumpPower.Locked then  
            humanoid.JumpPower = CharacterSettings.JumpPower.Value  
        end  
    end  
end  
Tabs.CharacterTab:Section({Title = gradient("Walkspeed", Color3.fromHex("#ff0000"), Color3.fromHex("#300000"))})  

Tabs.CharacterTab:Slider(  
    {  
        Title = "Walkspeed",  
        Value = {Min = 0, Max = 200, Default = 16},  
        Callback = function(value)  
            CharacterSettings.WalkSpeed.Value = value  
            updateCharacter()  
        end  
    }  
)  

Tabs.CharacterTab:Button(  
    {  
        Title = "Reset walkspeed",  
        Callback = function()  
            CharacterSettings.WalkSpeed.Value = CharacterSettings.WalkSpeed.Default  
            updateCharacter()  
        end  
    }  
)  

Tabs.CharacterTab:Toggle(  
    {  
        Title = "Block walkspeed",  
        Default = false,  
        Callback = function(state)  
            CharacterSettings.WalkSpeed.Locked = state  
            updateCharacter()  
        end  
    }  
)  

Tabs.CharacterTab:Section({Title = gradient("JumpPower", Color3.fromHex("#001aff"), Color3.fromHex("#020524"))})  

Tabs.CharacterTab:Slider(  
    {  
        Title = "Jumppower",  
        Value = {Min = 0, Max = 200, Default = 50},  
        Callback = function(value)  
            CharacterSettings.JumpPower.Value = value  
            updateCharacter()  
        end  
    }  
)  

Tabs.CharacterTab:Button(  
    {  
        Title = "Reset jumppower",  
        Callback = function()  
            CharacterSettings.JumpPower.Value = CharacterSettings.JumpPower.Default  
            updateCharacter()  
        end  
    }  
)  

Tabs.CharacterTab:Toggle(  
    {  
        Title = "Block jumppower",  
        Default = false,  
        Callback = function(state)  
            CharacterSettings.JumpPower.Locked = state  
            updateCharacter()  
        end  
    }  
)  

-- ESP  
local ReplicatedStorage = game:GetService("ReplicatedStorage")  
local Players = game:GetService("Players")  
local RunService = game:GetService("RunService")  
local LP = Players.LocalPlayer  

local ESPConfig = {  
    HighlightMurderer = false,  
    HighlightInnocent = false,  
    HighlightSheriff = false  
}  

local Murder, Sheriff, Hero  
local roles = {}  

function CreateHighlight(player)  
    if player ~= LP and player.Character and not player.Character:FindFirstChild("Highlight") then  
        local highlight = Instance.new("Highlight")  
        highlight.Parent = player.Character  
        highlight.Adornee = player.Character  
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop  
        return highlight  
    end  
    return player.Character and player.Character:FindFirstChild("Highlight")  
end  

function RemoveAllHighlights()  
    for _, player in pairs(Players:GetPlayers()) do  
        if player.Character and player.Character:FindFirstChild("Highlight") then  
            player.Character.Highlight:Destroy()  
        end  
    end  
end  

function UpdateHighlights()  
    for _, player in pairs(Players:GetPlayers()) do  
        if player ~= LP and player.Character then  
            local highlight = player.Character:FindFirstChild("Highlight")  
            if not (ESPConfig.HighlightMurderer or ESPConfig.HighlightInnocent or ESPConfig.HighlightSheriff) then  
                if highlight then  
                    highlight:Destroy()  
                end  
                return  
            end  

            local shouldHighlight = false  
            local color = Color3.new(0, 1, 0)  
            if player.Name == Murder and IsAlive(player) and ESPConfig.HighlightMurderer then  
                color = Color3.fromRGB(255, 0, 0)  
                shouldHighlight = true  
            elseif player.Name == Sheriff and IsAlive(player) and ESPConfig.HighlightSheriff then  
                color = Color3.fromRGB(0, 0, 255)  
                shouldHighlight = true  
            elseif  
                ESPConfig.HighlightInnocent and IsAlive(player) and player.Name ~= Murder and player.Name ~= Sheriff and  
                    player.Name ~= Hero  
             then  
                color = Color3.fromRGB(0, 255, 0)  
                shouldHighlight = true  
            elseif  
                player.Name == Hero and IsAlive(player) and not IsAlive(game.Players[Sheriff]) and  
                    ESPConfig.HighlightSheriff  
             then  
                color = Color3.fromRGB(255, 250, 0)  
                shouldHighlight = true  
            end  

            if shouldHighlight then  
                highlight = CreateHighlight(player)  
                if highlight then  
                    highlight.FillColor = color  
                    highlight.OutlineColor = color  
                    highlight.Enabled = true  
                end  
            elseif highlight then  
                highlight.Enabled = false  
            end  
        end  
    end  
end  

function IsAlive(player)  
    for name, data in pairs(roles) do  
        if player.Name == name then  
            return not data.Killed and not data.Dead  
        end  
    end  
    return false  
end  

local function UpdateRoles()  
    roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()  
    for name, data in pairs(roles) do  
        if data.Role == "Murderer" then  
            Murder = name  
        elseif data.Role == "Sheriff" then  
            Sheriff = name  
        elseif data.Role == "Hero" then  
            Hero = name  
        end  
    end  
end  

Tabs.EspTab:Section({Title = gradient("Special ESP", Color3.fromHex("#b914fa"), Color3.fromHex("#7023c2"))})  

Tabs.EspTab:Toggle(  
    {  
        Title = gradient("Higlight Murder", Color3.fromHex("#e80909"), Color3.fromHex("#630404")),  
        Default = false,  
        Callback = function(state)  
            ESPConfig.HighlightMurderer = state  
            if not state then  
                UpdateHighlights()  
            end  
        end  
    }  
)  

Tabs.EspTab:Toggle(  
    {  
        Title = gradient("Highlight Innocent", Color3.fromHex("#0ff707"), Color3.fromHex("#1e690c")),  
        Default = false,  
        Callback = function(state)  
            ESPConfig.HighlightInnocent = state  
            if not state then  
                UpdateHighlights()  
            end  
        end  
    }  
)  

Tabs.EspTab:Toggle(  
    {  
        Title = gradient("Highlight Sheriff", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9")),  
        Default = false,  
        Callback = function(state)  
            ESPConfig.HighlightSheriff = state  
            if not state then  
                UpdateHighlights()  
            end  
        end  
    }  
)  

local gunDropESPEnabled = false  
local gunDropHighlight = nil  

-- –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∫–∞—Ä—Ç  
local mapPaths = {  
    "ResearchFacility",  
    "Hospital3",  
    "MilBase",  
    "House2",  
    "Workplace",  
    "Mansion2",  
    "BioLab",  
    "Hotel",  
    "Factory",  
    "Bank2",  
    "PoliceStation"  
}  

-- –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –¥–ª—è GunDrop  
local function createGunDropHighlight(gunDrop)  
    if gunDropESPEnabled and gunDrop and not gunDrop:FindFirstChild("GunDropHighlight") then  
        local highlight = Instance.new("Highlight")  
        highlight.Name = "GunDropHighlight"  
        highlight.FillColor = Color3.fromRGB(255, 215, 0) -- –ó–æ–ª–æ—Ç–æ–π —Ü–≤–µ—Ç  
        highlight.OutlineColor = Color3.fromRGB(255, 165, 0)  
        highlight.Adornee = gunDrop  
        highlight.Parent = gunDrop  
    end  
end  

-- –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è ESP  
local function updateGunDropESP()  
    -- –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –ø–æ–¥—Å–≤–µ—Ç–∫–∏  
    for _, mapName in pairs(mapPaths) do  
        local map = workspace:FindFirstChild(mapName)  
        if map then  
            local gunDrop = map:FindFirstChild("GunDrop")  
            if gunDrop and gunDrop:FindFirstChild("GunDropHighlight") then  
                gunDrop.GunDropHighlight:Destroy()  
            end  
        end  
    end  

    -- –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –µ—Å–ª–∏ ESP –≤–∫–ª—é—á–µ–Ω  
    if gunDropESPEnabled then  
        for _, mapName in pairs(mapPaths) do  
            local map = workspace:FindFirstChild(mapName)  
            if map then  
                local gunDrop = map:FindFirstChild("GunDrop")  
                if gunDrop then  
                    createGunDropHighlight(gunDrop)  
                end  
            end  
        end  
    end  
end  

-- –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–æ—è–≤–ª–µ–Ω–∏—è GunDrop –Ω–∞ –≤—Å–µ—Ö –∫–∞—Ä—Ç–∞—Ö  
local function monitorGunDrops()  
    for _, mapName in pairs(mapPaths) do  
        local map = workspace:FindFirstChild(mapName)  
        if map then  
            map.ChildAdded:Connect(  
                function(child)  
                    if child.Name == "GunDrop" then  
                        createGunDropHighlight(child)  
                    end  
                end  
            )  
        end  
    end  
end  

monitorGunDrops()  

Tabs.EspTab:Toggle(  
    {  
        Title = gradient("GunDrop Highlight", Color3.fromHex("#ffff00"), Color3.fromHex("#4f4f00")),  
        Default = false,  
        Callback = function(state)  
            gunDropESPEnabled = state  
            updateGunDropESP()  
        end  
    }  
)  

-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ —Å–º–µ–Ω–µ –∫–∞—Ä—Ç—ã  
workspace.ChildAdded:Connect(  
    function(child)  
        if table.find(mapPaths, child.Name) then  
            task.wait(2) -- –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫—É –∫–∞—Ä—Ç—ã  
            updateGunDropESP()  
        end  
    end  
)  

RunService.RenderStepped:Connect(  
    function()  
        UpdateRoles()  
        if ESPConfig.HighlightMurderer or ESPConfig.HighlightInnocent or ESPConfig.HighlightSheriff then  
            UpdateHighlights()  
        end  
    end  
)  

Players.PlayerRemoving:Connect(  
    function(player)  
        if player == LP then  
            RemoveAllHighlights()  
        end  
    end  
)  



-- Teleport  
local teleportTarget = nil  

local function updateTeleportPlayers()  
    local playersList = {}  
    for _, player in pairs(Players:GetPlayers()) do  
        if player ~= LocalPlayer then  
            table.insert(playersList, player.Name)  
        end  
    end  
    return playersList  
end  

Tabs.TeleportTab:Section({Title = gradient("Default TP", Color3.fromHex("#00448c"), Color3.fromHex("#0affd6"))})  

local teleportDropdown =  
    Tabs.TeleportTab:Dropdown(  
    {  
        Title = "Players",  
        Values = updateTeleportPlayers(),  
        Value = "Select Player",  
        Callback = function(selected)  
            teleportTarget = Players:FindFirstChild(selected)  
        end  
    }  
)  

local function teleportToPlayer()  
    if teleportTarget and teleportTarget.Character then  
        local targetRoot = teleportTarget.Character:FindFirstChild("HumanoidRootPart")  
        local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")  

        if targetRoot and localRoot then  
            localRoot.CFrame = targetRoot.CFrame  
            WindUI:Notify(  
                {  
                    Title = "Teleportation",  
                    Content = "Successfully teleported to " .. teleportTarget.Name,  
                    Icon = "check-circle",  
                    Duration = 3  
                }  
            )  
        end  
    else  
        WindUI:Notify(  
            {  
                Title = "Error",  
                Content = "Target not found or unavailable",  
                Icon = "x-circle",  
                Duration = 3  
            }  
        )  
    end  
end  

Tabs.TeleportTab:Button(  
    {  
        Title = "Teleport to player",  
        Callback = teleportToPlayer  
    }  
)  

Tabs.TeleportTab:Button(  
    {  
        Title = "Update players list",  
        Callback = function()  
            teleportDropdown:Refresh(updateTeleportPlayers()) -- ‚úÖ CORRECT  
        end  
    }  
)  

Players.PlayerAdded:Connect(  
    function()  
        teleportDropdown:Refresh(updateTeleportPlayers())  
    end  
)  

Players.PlayerRemoving:Connect(  
    function()  
        teleportDropdown:Refresh(updateTeleportPlayers())  
    end  
)  

teleportDropdown:Refresh(updateTeleportPlayers())  

Tabs.TeleportTab:Section({Title = gradient("Special TP", Color3.fromHex("#b914fa"), Color3.fromHex("#7023c2"))})  

Tabs.TeleportTab:Button(  
    {  
        Title = "Teleport to Sheriff",  
        Callback = function()  
            UpdateRoles()  
            if Sheriff then  
                local sheriffPlayer = Players:FindFirstChild(Sheriff)  
                if sheriffPlayer and sheriffPlayer.Character then  
                    local targetRoot = sheriffPlayer.Character:FindFirstChild("HumanoidRootPart")  
                    local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")  

                    if targetRoot and localRoot then  
                        localRoot.CFrame = targetRoot.CFrame  
                        WindUI:Notify(  
                            {  
                                Title = "Teleportation",  
                                Content = "Successfully teleported to the sheriff " .. Sheriff,  
                                Icon = "check-circle",  
                                Duration = 3  
                            }  
                        )  
                    end  
                else  
                    WindUI:Notify(  
                        {  
                            Title = "Error",  
                            Content = "Sheriff not found or unavailable",  
                            Icon = "x-circle",  
                            Duration = 3  
                        }  
                    )  
                end  
            else  
                WindUI:Notify(  
                    {  
                        Title = "Error",  
                        Content = "Sheriff is not defined in the current match",  
                        Icon = "x-circle",  
                        Duration = 3  
                    }  
                )  
            end  
        end  
    }  
)  

Tabs.TeleportTab:Button(  
    {  
        Title = "Teleport to Murderer",  
        Callback = function()  
            UpdateRoles()  
            if Murder then  
                local murderPlayer = Players:FindFirstChild(Murder)  
                if murderPlayer and murderPlayer.Character then  
                    local targetRoot = murderPlayer.Character:FindFirstChild("HumanoidRootPart")  
                    local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")  

                    if targetRoot and localRoot then  
                        localRoot.CFrame = targetRoot.CFrame  
                        WindUI:Notify(  
                            {  
                                Title = "Teleportation",  
                                Content = "Successfully teleported to the murderer " .. Murder,  
                                Icon = "check-circle",  
                                Duration = 3  
                            }  
                        )  
                    end  
                else  
                    WindUI:Notify(  
                        {  
                            Title = "Error",  
                            Content = "Murderer not found or unavailable",  
                            Icon = "x-circle",  
                            Duration = 3  
                        }  
                    )  
                end  
            else  
                WindUI:Notify(  
                    {  
                        Title = "Error",  
                        Content = "Murderer is not defined in the current match",  
                        Icon = "x-circle",  
                        Duration = 3  
                    }  
                )  
            end  
        end  
    }  
)  

Players.PlayerAdded:Connect(  
    function()  
        teleportDropdown:Refresh({updateTeleportPlayers()})  
    end  
)  

Players.PlayerRemoving:Connect(  
    function()  
        teleportDropdown:Refresh({updateTeleportPlayers()})  
    end  
)  

-- Aimbot  
local roles = {}  
local Murder, Sheriff  
local isCameraLocked = false  
local isSpectating = false  
local lockedRole = nil  
local cameraConnection = nil  
local originalCameraType = Enum.CameraType.Custom  
local originalCameraSubject = nil  

function IsAlive(player)  
    for name, data in pairs(roles) do  
        if player.Name == name then  
            return not data.Killed and not data.Dead  
        end  
    end  
    return false  
end  

local function UpdateRoles()  
    local success, result =  
        pcall(  
        function()  
            return ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()  
        end  
    )  
    if success then  
        roles = result or {}  
        Murder, Sheriff = nil, nil  
        for name, data in pairs(roles) do  
            if data.Role == "Murderer" then  
                Murder = name  
            elseif data.Role == "Sheriff" then  
                Sheriff = name  
            end  
        end  
    end  
end  

Tabs.AimbotTab:Section({Title = gradient("Default AimBot", Color3.fromHex("#00448c"), Color3.fromHex("#0affd6"))})  

RoleDropdown =  
    Tabs.AimbotTab:Dropdown(  
    {  
        Title = "Target Role",  
        Values = {"None", "Sheriff", "Murderer"},  
        Value = "None",  
        Callback = function(selected)  
            lockedRole = (selected ~= "None") and selected or nil  
        end  
    }  
)  

Tabs.AimbotTab:Toggle(  
    {  
        Title = "Spectate Mode",  
        Default = false,  
        Callback = function(state)  
            isSpectating = state  
            if state then  
                originalCameraType = CurrentCamera.CameraType  
                originalCameraSubject = CurrentCamera.CameraSubject  
                CurrentCamera.CameraType = Enum.CameraType.Scriptable  
            else  
                CurrentCamera.CameraType = originalCameraType  
                CurrentCamera.CameraSubject = originalCameraSubject  
            end  
        end  
    }  
)  

Tabs.AimbotTab:Toggle(  
    {  
        Title = "Lock Camera",  
        Default = false,  
        Callback = function(state)  
            isCameraLocked = state  
            if not state and not isSpectating then  
                CurrentCamera.CameraType = originalCameraType  
                CurrentCamera.CameraSubject = originalCameraSubject  
            end  
        end  
    }  
)  

local function GetTargetPosition()  
    if not lockedRole then  
        return nil  
    end  
    local targetName = lockedRole == "Sheriff" and Sheriff or Murder  
    if not targetName then  
        return nil  
    end  
    local player = Players:FindFirstChild(targetName)  
    if not player or not IsAlive(player) then  
        return nil  
    end  
    local character = player.Character  
    if not character then  
        return nil  
    end  
    local head = character:FindFirstChild("Head")  
    return head and head.Position or nil  
end  

local function UpdateSpectate()  
    if not isSpectating or not lockedRole then  
        return  
    end  
    local targetPos = GetTargetPosition()  
    if not targetPos then  
        return  
    end  
    local offset = CFrame.new(0, 2, 8)  
    local targetChar = Players:FindFirstChild(lockedRole == "Sheriff" and Sheriff or Murder).Character  
    if targetChar then  
        local root = targetChar:FindFirstChild("HumanoidRootPart")  
        if root then  
            CurrentCamera.CFrame = root.CFrame * offset  
        end  
    end  
end  

local function UpdateLockCamera()  
    if not isCameraLocked or not lockedRole then  
        return  
    end  
    local targetPos = GetTargetPosition()  
    if not targetPos then  
        return  
    end  
    local currentPos = CurrentCamera.CFrame.Position  
    CurrentCamera.CFrame = CFrame.new(currentPos, targetPos)  
end  

local function Update()  
    if isSpectating then  
        UpdateSpectate()  
    elseif isCameraLocked then  
        UpdateLockCamera()  
    end  
end  

local function AutoUpdate()  
    while true do  
        UpdateRoles()  
        task.wait(3)  
    end  
end  

coroutine.wrap(AutoUpdate)()  
cameraConnection = RunService.RenderStepped:Connect(Update)  

LocalPlayer.AncestryChanged:Connect(  
    function()  
        if not LocalPlayer.Parent and cameraConnection then  
            cameraConnection:Disconnect()  
            CurrentCamera.CameraType = originalCameraType  
            CurrentCamera.CameraSubject = originalCameraSubject  
        end  
    end  
)  

UpdateRoles()  

local SilentAim = {  
    Enabled = false,  
    Prediction = 0.14  
}  

-- –ü–æ–ª—É—á–∞–µ–º —É–±–∏–π—Ü—É  
local function GetMurderer()  
    local success, roles =  
        pcall(  
        function()  
            return game:GetService("ReplicatedStorage"):FindFirstChild("GetPlayerData", true):InvokeServer()  
        end  
    )  
    if success and roles then  
        for name, data in pairs(roles) do  
            if data.Role == "Murderer" then  
                return game:GetService("Players"):FindFirstChild(name)  
            end  
        end  
    end  
    return nil  
end  

-- –û—Å–Ω–æ–≤–Ω–æ–π —Ö—É–∫  
local oldNamecall  
oldNamecall =  
    hookmetamethod(  
    game,  
    "__namecall",  
    function(self, ...)  
        if SilentAim.Enabled and not checkcaller() then  
            local method = getnamecallmethod()  
            if method == "InvokeServer" and tostring(self) == "HitPart" then  
                local murderer = GetMurderer()  
                if murderer and murderer.Character then  
                    local head = murderer.Character:FindFirstChild("Head")  
                    if head then  
                        local root = murderer.Character:FindFirstChild("HumanoidRootPart")  
                        local predictedPos = root.Position + (root.Velocity * SilentAim.Prediction)  
                        return oldNamecall(self, predictedPos, head)  
                    end  
                end  
            end  
        end  
        return oldNamecall(self, ...)  
    end  
)  

-- –ü—Ä–æ—Å—Ç–æ —Ç–æ–≥–≥–ª –≤ UI  
local Toggle =  
    Tabs.AimbotTab:Toggle(  
    {  
        Title = "Silent Aim",  
        Default = false,  
        Callback = function(state)  
            SilentAim.Enabled = state  
        end  
    }  
)  

-- Combat  
local function KnifeKillNearest()  
    local nearestPlayer, minDist = nil, math.huge  
    for _, player in ipairs(game.Players:GetPlayers()) do  
        if player ~= LocalPlayer and player.Character then  
            local dist =  
                (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude  
            if dist < minDist then  
                nearestPlayer = player  
                minDist = dist  
            end  
        end  
    end  

    if nearestPlayer then  
        game:GetService("ReplicatedStorage").Remotes.Gameplay.KnifeKill:FireServer(  
            nearestPlayer.Character.HumanoidRootPart.Position  
        )  
    end  
end  

local function EquipWeapon()  
    local role = roles[game.Players.LocalPlayer.Name].Role  
    local weaponType = (role == "Sheriff") and "Gun" or "Knife"  

    game:GetService("ReplicatedStorage").Remotes.Inventory.Equip:FireServer(weaponType)  
end  

Tabs.CombatTab:Section(  
    {  
        Title = gradient("For all roles", Color3.fromHex("#ffff00"), Color3.fromHex("#4f4f00"))  
    }  
)  

Tabs.CombatTab:Button(  
    {  
        Title = "Auto-Equip Weapon",  
        Callback = EquipWeapon  
    }  
)  

Tabs.CombatTab:Section(  
    {  
        Title = gradient("Innocent", Color3.fromHex("#0ff707"), Color3.fromHex("#1e690c"))  
    }  
)  

-- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è  
local config = {  
    GunDropESP = false,  
    AutoGrabGun = false,  
    NotifyGunDrop = true,  
    HighlightColor = Color3.fromRGB(255, 215, 0), -- –ó–æ–ª–æ—Ç–æ–π  
    OutlineColor = Color3.fromRGB(255, 165, 0),  
    CheckInterval = 1 -- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É  
}  

-- –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–∞—Ä—Ç  
local mapPaths = {  
    "ResearchFacility",  
    "Hospital3",  
    "MilBase",  
    "House2",  
    "Workplace",  
    "Mansion2",  
    "BioLab",  
    "Hotel",  
    "Factory",  
    "Bank2",  
    "PoliceStation"  
}  

-- –ö—ç—à –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö GunDrop  
local activeGunDrops = {}  

-- –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ GunDrop  
local function scanForGunDrops()  
    activeGunDrops = {} -- –û—á–∏—â–∞–µ–º –∫—ç—à  

    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –∫–∞—Ä—Ç—ã  
    for _, mapName in pairs(mapPaths) do  
        local map = workspace:FindFirstChild(mapName)  
        if map then  
            local gunDrop = map:FindFirstChild("GunDrop")  
            if gunDrop then  
                table.insert(activeGunDrops, gunDrop)  
                if config.GunDropESP then  
                    createGunDropVisual(gunDrop)  
                end  
            end  
        end  
    end  

    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π workspace  
    local rootGunDrop = workspace:FindFirstChild("GunDrop")  
    if rootGunDrop then  
        table.insert(activeGunDrops, rootGunDrop)  
        if config.GunDropESP then  
            createGunDropVisual(rootGunDrop)  
        end  
    end  

    -- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω–∞—à–ª–∏ –Ω–æ–≤—ã–π GunDrop  
    if config.NotifyGunDrop and #activeGunDrops > 0 then  
        WindUI:Notify(  
            {  
                Title = "Gun Drop Spawned",  
                Content = "Sheriff was killed. Gun is available!",  
                Icon = "alert-circle",  
                Duration = 5  
            }  
        )  
    end  

    -- –ê–≤—Ç–æ–ø–æ–¥–±–æ—Ä –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω  
    if config.AutoGrabGun and #activeGunDrops > 0 then  
        local nearestGun = nil  
        local minDist = math.huge  

        -- –ò—â–µ–º –±–ª–∏–∂–∞–π—à–∏–π GunDrop  
        for _, gunDrop in pairs(activeGunDrops) do  
            local dist = (LocalPlayer.Character.HumanoidRootPart.Position - gunDrop.Position).Magnitude  
            if dist < minDist then  
                nearestGun = gunDrop  
                minDist = dist  
            end  
        end  

        -- –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è –∏ –ø–æ–¥–±–∏—Ä–∞–µ–º  
        if nearestGun then  
            LocalPlayer.Character.HumanoidRootPart.CFrame = nearestGun.CFrame  
            task.wait(0.3)  
            fireproximityprompt(nearestGun:FindFirstChildOfClass("ProximityPrompt"))  
        end  
    end  
end  

-- –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –Ω–æ–≤—ã—Ö GunDrop  
local function monitorNewGunDrops()  
    for _, mapName in pairs(mapPaths) do  
        local map = workspace:FindFirstChild(mapName)  
        if map then  
            map.ChildAdded:Connect(  
                function(child)  
                    if child.Name == "GunDrop" then  
                        table.insert(activeGunDrops, child)  
                        if config.GunDropESP then  
                            createGunDropVisual(child)  
                        end  
                        scanForGunDrops() -- –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫  
                    end  
                end  
            )  
        end  
    end  
end  

Tabs.CombatTab:Toggle(  
    {  
        Title = "Auto Grab Gun",  
        Default = false,  
        Callback = function(state)  
            config.AutoGrabGun = state  
        end  
    }  
)  

Tabs.CombatTab:Toggle(  
    {  
        Title = "Notify GunDrop",  
        Default = true,  
        Callback = function(state)  
            config.NotifyGunDrop = state  
        end  
    }  
)  

Tabs.CombatTab:Button(  
    {  
        Title = "Grab Nearest Gun",  
        Callback = function()  
            scanForGunDrops()  
            if #activeGunDrops > 0 then  
                local nearest = activeGunDrops[1]  
                LocalPlayer.Character.HumanoidRootPart.CFrame = nearest.CFrame  
                task.wait(0.3)  
                fireproximityprompt(nearest:FindFirstChildOfClass("ProximityPrompt"))  
            else  
                WindUI:Notify(  
                    {  
                        Title = "No Gun Found",  
                        Content = "There are no guns available on the map",  
                        Icon = "x-circle",  
                        Duration = 3  
                    }  
                )  
            end  
        end  
    }  
)  

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è  
monitorNewGunDrops()  

-- –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª  
coroutine.wrap(  
    function()  
        while true do  
            scanForGunDrops()  
            if config.GunDropESP then  
                updateGunDropDistance()  
            end  
            task.wait(config.CheckInterval)  
        end  
    end  
)()  

Tabs.CombatTab:Section(  
    {  
        Title = gradient("Murder", Color3.fromHex("#e80909"), Color3.fromHex("#630404"))  
    }  
)  

local function KillSheriff()  
    -- –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ —à–µ—Ä–∏—Ñ–∞  
    local sheriffName = nil  
    local roles = game:GetService("ReplicatedStorage"):FindFirstChild("GetPlayerData", true):InvokeServer()  
    for name, data in pairs(roles) do  
        if data.Role == "Sheriff" then  
            sheriffName = name  
            break  
        end  
    end  

    if sheriffName then  
        local sheriff = game.Players:FindFirstChild(sheriffName)  
        if sheriff and sheriff.Character then  
            -- –¢–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏—è –∫ —à–µ—Ä–∏—Ñ—É  
            LocalPlayer.Character.HumanoidRootPart.CFrame = sheriff.Character.HumanoidRootPart.CFrame  

            -- –£–±–∏–π—Å—Ç–≤–æ  
            game:GetService("ReplicatedStorage").Remotes.Gameplay.KnifeKill:FireServer(  
                sheriff.Character.HumanoidRootPart.Position  
            )  

            WindUI:Notify(  
                {  
                    Title = "Kill Sheriff",  
                    Content = "Successfully killed the sheriff!",  
                    Icon = "check-circle",  
                    Duration = 3  
                }  
            )  
        end  
    else  
        WindUI:Notify(  
            {  
                Title = "Error",  
                Content = "Sheriff not found!",  
                Icon = "x-circle",  
                Duration = 3  
            }  
        )  
    end  
end  

Tabs.CombatTab:Button(  
    {  
        Title = "Kill Sheriff",  
        Callback = KillSheriff  
    }  
)  

Tabs.CombatTab:Button(  
    {  
        Title = "Kill Player",  
        Callback = function()  
            local players = {}  
            for _, player in ipairs(game.Players:GetPlayers()) do  
                if  
                    player ~= LocalPlayer and player.Character and  
                        player.Character:FindFirstChild("HumanoidRootPart")  
                 then  
                    table.insert(players, player)  
                end  
            end  

            -- –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é (–æ—Ç –±–ª–∏–∂–Ω–µ–≥–æ –∫ –¥–∞–ª—å–Ω–µ–º—É)  
            table.sort(  
                players,  
                function(a, b)  
                    local aDist =  
                        (a.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude  
                    local bDist =  
                        (b.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude  
                    return aDist < bDist  
                end  
            )  

            -- –£–±–∏–≤–∞–µ–º –ø–æ –æ—á–µ—Ä–µ–¥–∏  
            for _, player in ipairs(players) do  
                -- –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è –∫ –∏–≥—Ä–æ–∫—É  
                LocalPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame  
                -- –£–±–∏–≤–∞–µ–º  
                game:GetService("ReplicatedStorage").Remotes.Gameplay.KnifeKill:FireServer(  
                    player.Character.HumanoidRootPart.Position  
                )  
            end  

            WindUI:Notify(  
                {  
                    Title = "Kill All",  
                    Content = "All players killed (nearest first)!",  
                    Icon = "check-circle",  
                    Duration = 3  
                }  
            )  
        end  
    }  
)  

local Remotes = {  
    Eliminate = game:GetService("ReplicatedStorage").Remotes.Gameplay.EliminatePlayer,  
    Perk = game:GetService("ReplicatedStorage").Remotes.Gameplay.ActivatePerk,  
    Kill = game:GetService("ReplicatedStorage").Remotes.Gameplay.KillEvent,  
    Gun = game:GetService("ReplicatedStorage").Remotes.Gameplay.GunKill,  
    Mobile = game:GetService("StarterGui").InteractGUI.Mobile.Use,  
    Equip = game:GetService("Players").LocalPlayer.PlayerGui.MainGUI.Gameplay.Equip  
}  

local function TryAllKillMethods(target)  
    if not target or not target.Character then  
        return false  
    end  

    local targetPart =  
        target.Character:FindFirstChild("Head") or target.Character:FindFirstChild("HumanoidRootPart")  
    if not targetPart then  
        return false  
    end  

    -- 1. –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã —É–±–∏–π—Å—Ç–≤–∞  
    pcall(  
        function()  
            Remotes.Gun:FireServer(targetPart.Position, targetPart)  
        end  
    )  
    pcall(  
        function()  
            Remotes.Kill:FireServer(targetPart.Position, targetPart)  
        end  
    )  
    pcall(  
        function()  
            Remotes.Eliminate:FireServer(target)  
        end  
    )  

    -- 2. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã (–ø–µ—Ä–∫–∏/–º–æ–±–∏–ª—å–Ω—ã–µ)  
    pcall(  
        function()  
            Remotes.Perk:FireServer("Damage", target)  
        end  
    )  
    pcall(  
        function()  
            Remotes.Mobile:Fire("Shoot")  
        end  
    )  

    -- 3. –§–æ—Ä—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∞ –æ—Ä—É–∂–∏—è  
    if not LocalPlayer.Character:FindFirstChildOfClass("Tool") then  
        pcall(  
            function()  
                Remotes.Equip:Fire("Gun")  
            end  
        )  
        task.wait(0.3)  
    end  

    return true  
end  

local function SmartShoot()  
    local murderer = GetMurderer()  
    if not murderer then  
        WindUI:Notify({Title = "Error", Content = "Murderer not found!", Icon = "x-circle"})  
        return  
    end  

    -- –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã –Ω–∞ —Ü–µ–ª—å  
    local head = murderer.Character:FindFirstChild("Head")  
    if head then  
        CurrentCamera.CFrame = CFrame.lookAt(CurrentCamera.CFrame.Position, head.Position)  
        task.wait(0.2)  
    end  

    -- –ü–æ–ø—ã—Ç–∫–∞ –≤—Å–µ—Ö –º–µ—Ç–æ–¥–æ–≤ —É–±–∏–π—Å—Ç–≤–∞  
    local success = TryAllKillMethods(murderer)  

    -- –í–∏–∑—É–∞–ª—å–Ω–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ  
    WindUI:Notify(  
        {  
            Title = success and "Success" or "Error",  
            Content = success and "Attack on " .. murderer.Name .. " executed!" or "Failed to attack",  
            Icon = success and "check-circle" or "x-circle"  
        }  
    )  
end  

Tabs.CombatTab:Section(  
    {  
        Title = gradient("Sheriff", Color3.fromHex("#001e80"), Color3.fromHex("#16f2d9"))  
    }  
)  

Tabs.CombatTab:Button(  
    {  
        Title = "Shoot Murderer",  
        Callback = SmartShoot  
    }  
)  
-- Settings  
local Settings = {  
    Hitbox = {  
        Enabled = false,  
        Size = 5,  
        Color = Color3.new(1, 0, 0),  
        Adornments = {},  
        Connections = {}  
    },  
    Noclip = {  
        Enabled = false,  
        Connection = nil  
    },  
    AntiAFK = {  
        Enabled = false,  
        Connection = nil  
    }  
}  

local function ToggleNoclip(state)  
    if state then  
        Settings.Noclip.Connection =  
            RunService.Stepped:Connect(  
            function()  
                local chr = LocalPlayer.Character  
                if chr then  
                    for _, part in pairs(chr:GetDescendants()) do  
                        if part:IsA("BasePart") then  
                            part.CanCollide = false  
                        end  
                    end  
                end  
            end  
        )  
    else  
        if Settings.Noclip.Connection then  
            Settings.Noclip.Connection:Disconnect()  
        end  
    end  
end  

local function UpdateHitboxes()  
    for _, plr in pairs(Players:GetPlayers()) do  
        if plr ~= LocalPlayer then  
            local chr = plr.Character  
            local box = Settings.Hitbox.Adornments[plr]  

            if chr and Settings.Hitbox.Enabled then  
                local root = chr:FindFirstChild("HumanoidRootPart")  
                if root then  
                    if not box then  
                        box = Instance.new("BoxHandleAdornment")  
                        box.Adornee = root  
                        box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)  
                        box.Color3 = Settings.Hitbox.Color  
                        box.Transparency = 0.4  
                        box.ZIndex = 10  
                        box.Parent = root  
                        Settings.Hitbox.Adornments[plr] = box  
                    else  
                        box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)  
                        box.Color3 = Settings.Hitbox.Color  
                    end  
                end  
            elseif box then  
                box:Destroy()  
                Settings.Hitbox.Adornments[plr] = nil  
            end  
        end  
    end  
end  

local function ToggleAntiAFK(state)  
    if state then  
        Settings.AntiAFK.Connection =  
            RunService.Heartbeat:Connect(  
            function()  
                pcall(  
                    function()  
                        local vu = game:GetService("VirtualUser")  
                        vu:CaptureController()  
                        vu:ClickButton2(Vector2.new())  
                    end  
                )  
            end  
        )  
    else  
        if Settings.AntiAFK.Connection then  
            Settings.AntiAFK.Connection:Disconnect()  
        end  
    end  
end  

Tabs.SettingsTab:Section(  
    {  
        Title = gradient("Hitboxes", Color3.fromHex("#ff0000"), Color3.fromHex("#ff8800"))  
    }  
)  

Tabs.SettingsTab:Toggle(  
    {  
        Title = "Hixboxes",  
        Callback = function(state)  
            Settings.Hitbox.Enabled = state  
            if state then  
                RunService.Heartbeat:Connect(UpdateHitboxes)  
            else  
                for _, box in pairs(Settings.Hitbox.Adornments) do  
                    box:Destroy()  
                end  
                Settings.Hitbox.Adornments = {}  
            end  
        end  
    }  
)  

Tabs.SettingsTab:Slider(  
    {  
        Title = "Hitbox size",  
        Value = {Min = 1, Max = 10, Default = 5},  
        Callback = function(val)  
            Settings.Hitbox.Size = val  
            UpdateHitboxes()  
        end  
    }  
)  

Tabs.SettingsTab:Colorpicker(  
    {  
        Title = "Hitbox color",  
        Default = Color3.new(1, 0, 0),  
        Callback = function(col)  
            Settings.Hitbox.Color = col  
            UpdateHitboxes()  
        end  
    }  
)  

Tabs.SettingsTab:Section(  
    {  
        Title = gradient("Character Functions", Color3.fromHex("#00eaff"), Color3.fromHex("#002a2e"))  
    }  
)  

Tabs.SettingsTab:Toggle(  
    {  
        Title = "Anti-AFK",  
        Callback = function(state)  
            Settings.AntiAFK.Enabled = state  
            ToggleAntiAFK(state)  
        end  
    }  
)  

Tabs.SettingsTab:Toggle(  
    {  
        Title = "NoClip",  
        Callback = function(state)  
            Settings.Noclip.Enabled = state  
            ToggleNoclip(state)  
        end  
    }  
)  

-- Auto Exec  

Tabs.SettingsTab:Section(  
    {  
        Title = gradient("Auto Execute", Color3.fromHex("#00ff40"), Color3.fromHex("#88f2a2"))  
    }  
)  

local AutoInject = {  
    Enabled = false,  
    ScriptURL = ""  
}  

Tabs.SettingsTab:Toggle(  
    {  
        Title = "Auto Inject on Rejoin/Hop",  
        Default = false,  
        Callback = function(state)  
            AutoInject.Enabled = state  
            if state then  
                SetupAutoInject()  
                WindUI:Notify(  
                    {  
                        Title = "Auto Inject",  
                        Content = "Auto-inject enabled! The script will restart automatically.",  
                        Duration = 3  
                    }  
                )  
            else  
                WindUI:Notify(  
                    {  
                        Title = "Auto Inject",  
                        Content = "Auto-inject disabled",  
                        Duration = 3  
                    }  
                )  
            end  
        end  
    }  
)  

local function SetupAutoInject()  
    if not AutoInject.Enabled then  
        return  
    end  

    local TeleportService = game:GetService("TeleportService")  
    local Players = game:GetService("Players")  
    local LocalPlayer = Players.LocalPlayer  

    spawn(  
        function()  
            wait(2)  
            if AutoInject.Enabled then  
                pcall(  
                    function()  
                        loadstring(game:HttpGet(AutoInject.ScriptURL))()  
                    end  
                )  
            end  
        end  
    )  

    LocalPlayer.OnTeleport:Connect(  
        function(state)  
            if state == Enum.TeleportState.Started and AutoInject.Enabled then  
                queue_on_teleport(  
                    [[  
            wait(2)  
            loadstring(game:HttpGet("]] ..  
                        AutoInject.ScriptURL .. [["))()  
        ]]  
                )  
            end  
        end  
    )  

    game:GetService("Players").PlayerRemoving:Connect(  
        function(player)  
            if player == LocalPlayer and AutoInject.Enabled then  
                queue_on_teleport(  
                    [[  
            wait(2)  
            loadstring(game:HttpGet("]] ..  
                        AutoInject.ScriptURL .. [["))()  
        ]]  
                )  
            end  
        end  
    )  
end  

Tabs.SettingsTab:Button(  
    {  
        Title = "Manual Re-Inject",  
        Callback = function()  
            pcall(  
                function()  
                    loadstring(game:HttpGet(AutoInject.ScriptURL))()  
                    WindUI:Notify(  
                        {  
                            Title = "Manual Inject",  
                            Content = "Script reloaded successfully!",  
                            Duration = 3  
                        }  
                    )  
                end  
            )  
        end  
    }  
)  

-- Socials  
Tabs.SocialsTab:Paragraph(  
    {  
        Title = gradient("MadoHub Discord", Color3.fromHex("#7289DA"), Color3.fromHex("#99aab5")),  
        Desc = "Join our Discord",  
        Image = "bird",  
        Color = "White",  
        Buttons = {  
            {  
                Title = "Join Discord",  
                Icon = "circle",  
                Callback = function()  
                    setclipboard("https://discord.gg/w9m6Q53Akb")  
                    WindUI:Notify(  
                        {  
                            Title = "Copied!",  
                            Content = "Discord link copied.\nPaste it anywhere in Discord or a browser.",  
                            Icon = "check-circle",  
                            Duration = 5  
                        }  
                    )  
                end  
            }  
        }  
    }  
)  

-- Changelogs  
Tabs.ChangelogsTab:Code(  
    {  
        Title = "Changelogs:",  
        Code = [[  
RELEASED:  
‚Ä¢ Added OP Beach Ball Farm

More functions will be added in future!
]]
}
)

Tabs.ChangelogsTab:Code(  
    {  
        Title = "Next update:",  
        Code = [[ The next update will be version V2]  
In future we will be add:  
‚Ä¢ Autofarm coins (when they come back ofc)  
‚Ä¢ TP to Lobby  
‚Ä¢ Fix bugs

Thank you for using MadoHub!
]]
}
)

-- Server  
local TeleportService = game:GetService("TeleportService")  
local HttpService = game:GetService("HttpService")  
local Players = game:GetService("Players")  

Tabs.ServerTab:Button(  
    {  
        Title = "Rejoin",  
        Callback = function()  
            local success, error =  
                pcall(  
                function()  
                    TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, Players.LocalPlayer)  
                end  
            )  
            if not success then  
                warn("Rejoin error:", error)  
            end  
        end  
    }  
)  

Tabs.ServerTab:Section(  
    {  
        Title = ""  
    }  
)  

Tabs.ServerTab:Button(  
    {  
        Title = "Server Hop",  
        Callback = function()  
            local placeId = game.PlaceId  
            local currentJobId = game.JobId  

            local function serverHop()  
                local servers = {}  
                local success, result =  
                    pcall(  
                    function()  
                        return HttpService:JSONDecode(  
                            HttpService:GetAsync(  
                                "https://games.roblox.com/v1/games/" ..  
                                    placeId .. "/servers/Public?sortOrder=Asc&limit=100"  
                            )  
                        )  
                    end  
                )  

                if success and result and result.data then  
                    for _, server in ipairs(result.data) do  
                        if server.id ~= currentJobId then  
                            table.insert(servers, server)  
                        end  
                    end  

                    if #servers > 0 then  
                        TeleportService:TeleportToPlaceInstance(placeId, servers[math.random(#servers)].id)  
                    else  
                        TeleportService:Teleport(placeId)  
                    end  
                else  
                    TeleportService:Teleport(placeId)  
                end  
            end  

            pcall(serverHop)  
        end  
    }  
)  

Tabs.ServerTab:Button(  
    {  
        Title = "Join to Lower Server",  
        Callback = function()  
            local placeId = game.PlaceId  
            local currentJobId = game.JobId  

            local function joinLowerServer()  
                local servers = {}  
                local success, result =  
                    pcall(  
                    function()  
                        return HttpService:JSONDecode(  
                            HttpService:GetAsync(  
                                "https://games.roblox.com/v1/games/" ..  
                                    placeId .. "/servers/Public?sortOrder=Asc&limit=100"  
                            )  
                        )  
                    end  
                )  

                if success and result and result.data then  
                    for _, server in ipairs(result.data) do  
                        if server.id ~= currentJobId and server.playing < (server.maxPlayers or 30) then  
                            table.insert(servers, server)  
                        end  
                    end  

                    table.sort(  
                        servers,  
                        function(a, b)  
                            return a.playing < b.playing  
                        end  
                    )  

                    if #servers > 0 then  
                        TeleportService:TeleportToPlaceInstance(placeId, servers[1].id)  
                    else  
                        TeleportService:Teleport(placeId)  
                    end  
                else  
                    TeleportService:Teleport(placeId)  
                end  
            end  

            pcall(joinLowerServer)  
        end  
    }  
)  

-- Configuration  
local HttpService = game:GetService("HttpService")  

local folderPath = "WindUI"  
makefolder(folderPath)  

local function SaveFile(fileName, data)  
    local filePath = folderPath .. "/" .. fileName .. ".json"  
    local jsonData = HttpService:JSONEncode(data)  
    writefile(filePath, jsonData)  
end  

local function LoadFile(fileName)  
    local filePath = folderPath .. "/" .. fileName .. ".json"  
    if isfile(filePath) then  
        local jsonData = readfile(filePath)  
        return HttpService:JSONDecode(jsonData)  
    end  
end  

local function ListFiles()  
    local files = {}  
    for _, file in ipairs(listfiles(folderPath)) do  
        local fileName = file:match("([^/]+)%.json$")  
        if fileName then  
            table.insert(files, fileName)  
        end  
    end  
    return files  
end  

Tabs.WindowTab:Section({Title = "Window"})  
local themeValues = {}  
for name, _ in pairs(WindUI:GetThemes()) do  
    table.insert(themeValues, name)  
end  

local themeDropdown =  
    Tabs.WindowTab:Dropdown(  
    {  
        Title = "Select Theme",  
        Multi = false,  
        AllowNone = false,  
        Value = nil,  
        Values = themeValues,  
        Callback = function(theme)  
            WindUI:SetTheme(theme)  
        end  
    }  
)  

themeDropdown:Select(WindUI:GetCurrentTheme())  

local ToggleTransparency =  
    Tabs.WindowTab:Toggle(  
    {  
        Title = "Toggle Window Transparency",  
        Callback = function(e)  
            Window:ToggleTransparency(e)  
        end,  
        Value = WindUI:GetTransparency()  
    }  
)  

Tabs.WindowTab:Section({Title = "Save"})  

local fileNameInput = ""  
Tabs.WindowTab:Input(  
    {  
        Title = "Write File Name",  
        PlaceholderText = "Enter file name",  
        Callback = function(text)  
            fileNameInput = text  
        end  
    }  
)  

Tabs.WindowTab:Button(  
    {  
        Title = "Save File",  
        Callback = function()  
            if fileNameInput ~= "" then  
                SaveFile(fileNameInput, {Transparent = WindUI:GetTransparency(), Theme = WindUI:GetCurrentTheme()})  
            end  
        end  
    }  
)  

Tabs.WindowTab:Section({Title = "Load"})  

local filesDropdown  
local files = ListFiles()  

filesDropdown =  
    Tabs.WindowTab:Dropdown(  
    {  
        Title = "Select File",  
        Multi = false,  
        AllowNone = true,  
        Values = files,  
        Callback = function(selectedFile)  
            fileNameInput = selectedFile  
        end  
    }  
)  

Tabs.WindowTab:Button(  
    {  
        Title = "Load File",  
        Callback = function()  
            if fileNameInput ~= "" then  
                local data = LoadFile(fileNameInput)  
                if data then  
                    WindUI:Notify(  
                        {  
                            Title = "File Loaded",  
                            Content = "Loaded data: " .. HttpService:JSONEncode(data),  
                            Duration = 5  
                        }  
                    )  
                    if data.Transparent then  
                        Window:ToggleTransparency(data.Transparent)  
                        ToggleTransparency:SetValue(data.Transparent)  
                    end  
                    if data.Theme then  
                        WindUI:SetTheme(data.Theme)  
                    end  
                end  
            end  
        end  
    }  
)  

Tabs.WindowTab:Button(  
    {  
        Title = "Overwrite File",  
        Callback = function()  
            if fileNameInput ~= "" then  
                SaveFile(fileNameInput, {Transparent = WindUI:GetTransparency(), Theme = WindUI:GetCurrentTheme()})  
            end  
        end  
    }  
)  

Tabs.WindowTab:Button(  
    {  
        Title = "Refresh List",  
        Callback = function()  
            filesDropdown:Refresh(ListFiles())  
        end  
    }  
)  

-- Themes  
local currentThemeName = WindUI:GetCurrentTheme()  
local themes = WindUI:GetThemes()  

local ThemeAccent = themes[currentThemeName].Accent  
local ThemeOutline = themes[currentThemeName].Outline  
local ThemeText = themes[currentThemeName].Text  
local ThemePlaceholderText = themes[currentThemeName].PlaceholderText  

function updateTheme()  
    WindUI:AddTheme(  
        {  
            Name = currentThemeName,  
            Accent = ThemeAccent,  
            Outline = ThemeOutline,  
            Text = ThemeText,  
            PlaceholderText = ThemePlaceholderText  
        }  
    )  
    WindUI:SetTheme(currentThemeName)  
end  

Tabs.CreateThemeTab:Colorpicker(  
    {  
        Title = "Background Color",  
        Default = Color3.fromHex(ThemeAccent),  
        Callback = function(color)  
            ThemeAccent = color  
        end  
    }  
)  

Tabs.CreateThemeTab:Colorpicker(  
    {  
        Title = "Outline Color",  
        Default = Color3.fromHex(ThemeOutline),  
        Callback = function(color)  
            ThemeOutline = color  
        end  
    }  
)  

Tabs.CreateThemeTab:Colorpicker(  
    {  
        Title = "Text Color",  
        Default = Color3.fromHex(ThemeText),  
        Callback = function(color)  
            ThemeText = color  
        end  
    }  
)  

Tabs.CreateThemeTab:Colorpicker(  
    {  
        Title = "Placeholder Text Color",  
        Default = Color3.fromHex(ThemePlaceholderText),  
        Callback = function(color)  
            ThemePlaceholderText = color  
        end  
    }  
)  

Tabs.CreateThemeTab:Button(  
    {  
        Title = "Update Theme",  
        Callback = function()  
            WindUI:AddTheme(  
                {  
                    Name = currentThemeName,  
                    Accent = ThemeAccent,  
                    Outline = ThemeOutline,  
                    Text = ThemeText,  
                    PlaceholderText = ThemePlaceholderText  
                }  
            )  
            WindUI:SetTheme(currentThemeName)  
            WindUI:Notify(  
                {  
                    Title = "Theme updated",  
                    Content = "New theme '" .. currentThemeName .. "' applied!",  
                    Duration = 3,  
                    Icon = "check-circle"  
                }  
            )  
        end  
    }  
)

end
